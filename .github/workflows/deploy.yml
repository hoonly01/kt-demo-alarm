name: Deploy to AWS EC2

on:
  push:
    branches:
      - main
  workflow_dispatch:

concurrency:
  group: kt-demo-alarm-deploy
  cancel-in-progress: true

jobs:
  test:
    runs-on: ubuntu-latest
    name: Run Tests
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install uv
        uses: astral-sh/setup-uv@v3
        with:
          enable-cache: false

      - name: Set up Python
        run: uv python install 3.12

      - name: Install dependencies
        run: uv sync --locked --dev

      - name: Run tests
        run: uv run python -m pytest tests/ -v

  build:
    needs: test
    runs-on: ubuntu-latest
    name: Build Docker Image
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build Docker image
        run: |
          docker build -t kt-demo-alarm:${{ github.sha }} .
          docker tag kt-demo-alarm:${{ github.sha }} kt-demo-alarm:latest

      - name: Save Docker image (gzipped tar)
        run: |
          docker save kt-demo-alarm:latest | gzip -c > kt-demo-alarm-image.tar.gz

      - name: Upload Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: kt-demo-alarm-image.tar.gz
          retention-days: 1

  deploy:
    needs: build
    runs-on: ubuntu-latest
    name: Deploy to EC2
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Docker image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image

      - name: Deploy to EC2
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
          KAKAO_REST_API_KEY: ${{ secrets.KAKAO_REST_API_KEY }}
          BOT_ID: ${{ secrets.BOT_ID }}
          API_KEY: ${{ secrets.API_KEY }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          SEOUL_BUS_API_KEY: ${{ secrets.SEOUL_BUS_API_KEY }}
        run: |
          set -euo pipefail

          # SSH key
          echo "$EC2_SSH_KEY" > ec2-key.pem
          chmod 600 ec2-key.pem

          # Create .env on runner (so secrets are guaranteed to be present)
          cat > .env <<EOF
          KAKAO_REST_API_KEY=${KAKAO_REST_API_KEY}
          BOT_ID=${BOT_ID}
          API_KEY=${API_KEY}
          GEMINI_API_KEY=${GEMINI_API_KEY}
          SEOUL_BUS_API_KEY=${SEOUL_BUS_API_KEY}
          DEBUG=false
          LOG_LEVEL=INFO
          DATABASE_PATH=/app/data/kt_demo_alarm.db
          CRAWLING_HOUR=8
          CRAWLING_MINUTE=30
          ROUTE_CHECK_HOUR=7
          ROUTE_CHECK_MINUTE=0
          EOF

          # Upload artifacts/config to EC2
          scp -o StrictHostKeyChecking=no -i ec2-key.pem \
            kt-demo-alarm-image.tar.gz \
            ${EC2_USERNAME}@${EC2_HOST}:/opt/kt-demo-alarm/kt-demo-alarm-image.tar.gz

          scp -o StrictHostKeyChecking=no -i ec2-key.pem \
            docker-compose.yml .env \
            ${EC2_USERNAME}@${EC2_HOST}:/opt/kt-demo-alarm/

          # Remote deploy
          ssh -o StrictHostKeyChecking=no -i ec2-key.pem \
            ${EC2_USERNAME}@${EC2_HOST} << 'ENDSSH'
            set -euo pipefail
            cd /opt/kt-demo-alarm

            # Make directory with sudo and change owner to $USER
            sudo mkdir -p data logs topis_attachments topis_cache
            sudo chown -R $USER:$USER data logs topis_attachments topis_cache
            chmod -R 777 data logs topis_attachments topis_cache

            # Stop old stack (ignore if not running)
            docker compose down || true

            # Load new image (uploaded as gzip)
            gunzip -c /opt/kt-demo-alarm/kt-demo-alarm-image.tar.gz | docker load
            rm -f /opt/kt-demo-alarm/kt-demo-alarm-image.tar.gz

            # Protect env file
            chmod 600 .env || true

            # Start without building (important!)
            docker compose up -d --no-build

            # Ensure appuser owns data and attachments inside container
            docker compose exec -u root kt-demo-alarm chown -R appuser:appuser /app/data /app/topis_attachments /app/topis_cache

            echo "Waiting for service health..."
            for i in {1..24}; do
              if curl -fsS http://localhost:8000/ > /dev/null 2>&1; then
                echo "✅ Service is healthy on localhost:8000"
                break
              fi
              echo "Attempt $i: not ready yet..."
              sleep 5
            done

            echo "docker compose ps:"
            docker compose ps

            echo "Recent logs:"
            docker compose logs --tail=50

            echo "Cleanup old images (keep last 24h):"
            docker image prune -af --filter "until=24h" || true
          ENDSSH

          # Cleanup runner files
          rm -f ec2-key.pem .env

      - name: Verify deployment (public)
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
        run: |
          set -euo pipefail
          echo "Checking public health endpoint..."
          for i in {1..10}; do
            if curl -fsS http://${EC2_HOST}:8000/ > /dev/null 2>&1; then
              echo "✅ Application is reachable: http://${EC2_HOST}:8000/"
              exit 0
            fi
            echo "Attempt $i: waiting..."
            sleep 5
          done
          echo "❌ Public health check failed (verify SG inbound 8000 + app binds 0.0.0.0)"
          exit 1

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "✅ Deployment successful!"
          else
            echo "❌ Deployment failed!"
            exit 1
          fi